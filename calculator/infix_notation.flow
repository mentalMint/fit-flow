import lingo/pegcode/driver;
import math/math;

export {
	Expr ::= Const, Var, BinOp;
	BinOp(name : string, left: Expr, right: Expr);
	Var(name: string);
	Const(value: double);
    calculate(ex: Expr, variables : Tree<string, double>) -> double;
    infixToString(ex: Expr) -> string;
    parse(source: string) -> Expr;
	simplify(ex : Expr) -> Expr;
}

calculate(ex : Expr, variables : Tree<string, double>) {
	switch(ex)
	{
		Const(c): c;
		Var(name): 
			switch (lookupTree(variables, name)) {
            	Some(num): num;
            	None(): 0.0;
			}
		BinOp(name, l, r):
			if (name == "+") {
				calculate(l, variables) + calculate(r, variables);
			} else if (name == "*") {
				calculate(l, variables) * calculate(r, variables);
			} else if (name == "-") {
				calculate(l, variables) - calculate(r, variables);
			} else if (name == "/") {
				calculate(l, variables) / calculate(r, variables);
			} else if (name == "^") {
				dpow(calculate(l, variables), calculate(r, variables));
			} else {
				0.0;
			}
	}
}

infixToString(ex : Expr) {
	switch(ex) {
		Const(c): d2s(c);
		Var(name): name;
		BinOp(name, l, r):
			if (name == "+") {
				"(" + infixToString(l) + " + " + infixToString(r) + ")";
			} else if (name == "*") { 
				 "(" + infixToString(l) + " * " + infixToString(r) + ")";
			} else if (name == "/") { 
				 "(" + infixToString(l) + " / " + infixToString(r) + ")";
			} else if (name == "^") { 
				 "(" + infixToString(l) + " ^ " + infixToString(r) + ")";
			} else { 
				 "(" + infixToString(l) + " - " + infixToString(r) + ")";
			}
	}
}

simplify(ex : Expr) {
	switch(ex) {
		BinOp(name, l, r):
			if (name == "+") {
				simp_l = simplify(l);
				simp_r = simplify(r);
				if (simp_l == Const(0.0)) {
					simp_r;
				} else if (simp_r == Const(0.0)) {
					simp_l;
				} else if (simp_l == simp_r) {
					BinOp("*", Const(2.0), simp_l);
				}  else {
					BinOp(name, simp_l, simp_r);
				}
			} else if (name == "*") {
				simp_l = simplify(l);
				simp_r = simplify(r);
				if (simp_l == Const(0.0) || simp_r == Const(0.0)) {
					Const(0.0);
				} else if (simp_l == Const(1.0)) {
					simp_r;
				} else if (simp_r == Const(0.0)) {
					simp_l;
				} else if (simp_l == simp_r) {
					BinOp("^", simp_l, Const(2.0));
				} else {
					BinOp(name, simp_l, simp_r);
				}
			} else if (name == "/") {
				simp_l = simplify(l);
				simp_r = simplify(r);
				if (simp_l == Const(0.0)) {
					Const(0.0);
				} elseif (simp_l == simp_r) {
					Const(1.0);
				} else {
					BinOp(name, simp_l, simp_r);
				}
			} else if (name == "^") {
				simp_l = simplify(l);
				simp_r = simplify(r);
				if (simp_r == Const(0.0)) {
					Const(1.0);
				} else if (simp_l == Const(0.0)) {
					Const(0.0);
				} else {
					BinOp(name, simp_l, simp_r);
				}
			} else {
				simp_l = simplify(l);
				simp_r = simplify(r);
				if (simp_l == simp_r) {
					Const(0.0);
				} else if (simp_r == Const(0.0)) {
					simp_l;
				} else {
					BinOp(name, simp_l, simp_r);
				}
			}

		default: ex;
	}
}

buildMul(xs : [flow]) {
	fold(xs[1], xs[0], \acc, x -> BinOp("*", acc, x));
}

buildOp(xs : [flow]) {
	fold(xs[2], xs[1], \acc, x -> BinOp(xs[0], acc, x));
}

arithGrammarOp : ref Maybe<[PegOp]> = ref None();

arithGrammar() {
	// Prepare the grammar in the given file using flow syntax for inlining a string from a file
	// but be sure to only do this once
	onlyOnce(arithGrammarOp, \ -> {
		compilePegGrammar("#include infix_notation.lingo");
	});
}

parse(source: string) {
	specialPegActions = {
		t1 = setTree(defaultPegActions.t, "buildOp", buildOp);
		SemanticActions(t1);
	}
	parsic(arithGrammar(), source, specialPegActions);
}