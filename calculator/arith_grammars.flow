import lingo/pegcode/driver;

// import infix-notation;
// import postfix-notation;

export {
	Expr ::= Add, Const, Mul, Var, BinOp;
	BinOp(name : string, left: Expr, right: Expr);
	Var(name: string);
	Const(value: double);
	Mul(left: Expr, right: Expr);
	Add(left: Expr, right: Expr);
    calculate(ex: Expr, variables : Tree<string, double>) -> double;
    print(ex: Expr) -> string;
    parse(source: string) -> Expr;
    // printPolish(ex: Expr) -> string;
    // parsePolish(source: string) -> Expr;
    // translateToRPN(source: string) -> string;
    // translateFromRPN(source: string) -> string;
}

calculate(ex: Expr, variables : Tree<string, double>)
{
	switch(ex)
	{
		Const(c): c;
		Var(name): 
			switch (lookupTree(variables, name)) {
            	Some(num): num;
            	None(): 0.0;
			}
		Add(l, r): calculate(l, variables) + calculate(r, variables);
		Mul(l, r): calculate(l, variables) * calculate(r, variables);
		BinOp(name, l, r):
			if (name == "+") {
				calculate(l, variables) + calculate(r, variables);
			} else if (name == "*") {
				calculate(l, variables) * calculate(r, variables);
			} else {
				0.0;
			}
	}
}

print(ex: Expr)
{
	switch(ex) {
		Const(c): d2s(c);
		Var(name): name;
		Add(l, r): "(" + print(l) + " + " + print(r) + ")";
		Mul(l, r): "(" + print(l) + " * " + print(r) + ")";
		BinOp(name, l, r):
			if (name == "+") {
				"(" + print(l) + " + " + print(r) + ")";
			} else { 
				 "(" + print(l) + " * " + print(r) + ")";
			}
	}
}

buildMul(xs : [flow]) {
	fold(xs[1], xs[0], \acc, x -> BinOp("*", acc, x));
}

buildSub(xs : [flow]) {
	fold(xs[1], xs[0], \acc, x -> Mul(acc, x));
}

arithGrammarOp : ref Maybe<[PegOp]> = ref None();

arithGrammar() {
	// Prepare the grammar in the given file using flow syntax for inlining a string from a file
	// but be sure to only do this once
	onlyOnce(arithGrammarOp, \ -> {
		compilePegGrammar("#include infix-notation.lingo");
	});
}

parse(source: string)
{
	specialPegActions = {
		t1 = setTree(defaultPegActions.t, "buildSub", buildSub);
		t2 = setTree(t1, "buildMul", buildMul);
		SemanticActions(t2);
	}
	parsic(arithGrammar(), source, specialPegActions);
}

// printPolish(ex: Expr)
// {
// 	switch(ex)
// 	{
// 		Const(c): d2s(c);
// 		Add(l, r): printPolish(l) + " " + printPolish(r) + " +";
// 		Mul(l, r): printPolish(l) + " " + printPolish(r) + " *";
// 	}
// }

// polishGrammarOp : ref Maybe<[PegOp]> = ref None();

// polishGrammar() {
// 	// Prepare the grammar in the given file using flow syntax for inlining a string from a file
// 	// but be sure to only do this once
// 	onlyOnce(polishGrammarOp, \ -> {
// 		compilePegGrammar("#include polish-grammar.lingo");
// 	});
// }

// spaceCanonize(source: string) -> string
// {
// 	lsource = ltrim(source);
// 	opCount = strCountOf(lsource, "+") + strCountOf(lsource, "*");
// 	canonViewStr = strRepeat(" ", opCount) + lsource;
// 	canonViewStr;
// }

// parsePolish(source: string) -> Expr
// {
// 	canonViewStr = spaceCanonize(source);
// 	parsic(polishGrammar(), canonViewStr, defaultPegActions);
// }

// translateFromRPN(source: string) -> string {
// 	expr = parsePolish(source);
//     print(expr);
// }

// translateToRPN(source: string) -> string {
// 	expr = parse(source);
//     printPolish(expr);
// }